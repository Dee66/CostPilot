// ProEngine module - encrypted WASM loading and execution

pub mod abi;
pub mod api;
pub mod crypto;
pub mod error;
pub mod errors;
pub mod host_bridge;
pub mod instantiate;
pub mod license;
pub mod loader;
pub mod pro_loader;
pub mod runtime;
pub mod wasm_runtime;
pub mod handle;

pub use abi::{ProEngineRequest as AbiRequest, ProEngineResponse as AbiResponse};
pub use api::{ProEngineExecutor, ProEngineRequest, ProEngineResponse};
pub use errors::ProEngineError;
pub use host_bridge::call_pro_engine;
pub use license::License;
pub use loader::{load_pro_engine_from_file, LicenseInfo, LoaderError};
pub use wasm_runtime::{WasmError, WasmRuntime, WasmSandboxConfig};
pub use handle::ProEngineHandle as WasmProEngineHandle;

#[cfg(not(target_arch = "wasm32"))]
pub use pro_loader::load_pro_engine;

use crate::engines::shared::error_model::CostPilotError;
use anyhow::Result;

/// ProEngine trait - implement this for WASM or native Premium engines
pub trait ProEngine {
    fn exec(&self, req: &AbiRequest) -> Result<AbiResponse, CostPilotError>;
}

// Generated by wit-bindgen from pro_engine.wit
// This module will be generated at build time
mod bindings {
    // Placeholder for wit-bindgen generated code
    pub struct ProEngine;

    impl ProEngine {
        pub fn scan(&self, _input: &str) -> Result<String, String> {
            Err("ProEngine not loaded".to_string())
        }
        pub fn predict(&self, _input: &str) -> Result<String, String> {
            Err("ProEngine not loaded".to_string())
        }
        pub fn explain(&self, _input: &str) -> Result<String, String> {
            Err("ProEngine not loaded".to_string())
        }
        pub fn autofix(&self, _input: &str) -> Result<String, String> {
            Err("ProEngine not loaded".to_string())
        }
        pub fn mapdeep(&self, _input: &str) -> Result<String, String> {
            Err("ProEngine not loaded".to_string())
        }
        pub fn trend(&self, _input: &str) -> Result<String, String> {
            Err("ProEngine not loaded".to_string())
        }
        pub fn enforce(&self, _input: &str) -> Result<String, String> {
            Err("ProEngine not loaded".to_string())
        }
    }
}

use bindings::ProEngine as ProEngineInstance;

/// Handle for ProEngine execution
pub struct ProEngineHandle {
    pub instance: ProEngineInstance,
    executor: Box<dyn ProEngineExecutor + Send + Sync>,
}

impl ProEngineHandle {
    pub fn new(executor: Box<dyn ProEngineExecutor + Send + Sync>) -> Self {
        Self {
            instance: ProEngineInstance,
            executor,
        }
    }

    pub fn execute(&self, req: ProEngineRequest) -> Result<ProEngineResponse, String> {
        self.executor.execute(req)
    }

    pub fn scan(&self, input: &str) -> Result<String> {
        self.instance
            .scan(input)
            .map_err(|e| anyhow::anyhow!("ProEngine scan failed: {}", e))
    }

    pub fn predict(&self, input: &str) -> Result<String> {
        self.instance
            .predict(input)
            .map_err(|e| anyhow::anyhow!("ProEngine predict failed: {}", e))
    }

    pub fn explain(&self, input: &str) -> Result<String> {
        self.instance
            .explain(input)
            .map_err(|e| anyhow::anyhow!("ProEngine explain failed: {}", e))
    }

    pub fn autofix(&self, input: &str) -> Result<String> {
        self.instance
            .autofix(input)
            .map_err(|e| anyhow::anyhow!("ProEngine autofix failed: {}", e))
    }

    pub fn mapdeep(&self, input: &str) -> Result<String> {
        self.instance
            .mapdeep(input)
            .map_err(|e| anyhow::anyhow!("ProEngine mapdeep failed: {}", e))
    }

    pub fn trend(&self, input: &str) -> Result<String> {
        self.instance
            .trend(input)
            .map_err(|e| anyhow::anyhow!("ProEngine trend failed: {}", e))
    }

    pub fn enforce(&self, input: &str) -> Result<String> {
        self.instance
            .enforce(input)
            .map_err(|e| anyhow::anyhow!("ProEngine enforce failed: {}", e))
    }
}

impl Clone for ProEngineHandle {
    fn clone(&self) -> Self {
        // Note: This creates a stub clone - real implementation would share executor
        Self::stub()
    }
}

impl ProEngineHandle {
    pub fn stub() -> Self {
        struct StubExecutor;
        impl ProEngineExecutor for StubExecutor {
            fn execute(&self, _req: ProEngineRequest) -> Result<ProEngineResponse, String> {
                Err("ProEngine not loaded".to_string())
            }
        }
        Self::new(Box::new(StubExecutor))
    }
}
