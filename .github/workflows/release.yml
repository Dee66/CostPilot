# MANUAL WORKFLOW â€” intentionally not automated. Run only when explicitly required.
name: Release

on:
  workflow_dispatch:

jobs:
  build:
    runs-on: ${{ matrix.os }}
    strategy:
      matrix:
        include:
          - os: ubuntu-latest
            target: x86_64-unknown-linux-gnu
            name: linux-amd64
            run_tests: true
          # ARM builds disabled for v1.0.0 (not available in private repos)
          # - os: ubuntu-22.04-arm
          #   target: aarch64-unknown-linux-gnu
          #   name: linux-arm64
          #   run_tests: false
          - os: macos-14
            target: x86_64-apple-darwin
            name: macos-amd64
            run_tests: true
          - os: macos-14
            target: aarch64-apple-darwin
            name: macos-arm64
            run_tests: true
          - os: windows-latest
            target: x86_64-pc-windows-msvc
            name: windows-amd64
            run_tests: true
          # - os: ubuntu-latest
          #   target: aarch64-pc-windows-msvc
          #   name: windows-arm64
          #   run_tests: false

    steps:
      - uses: actions/checkout@v4

      - name: Cache Rust dependencies
        uses: actions/cache@v3
        with:
          path: |
            ~/.cargo/registry
            ~/.cargo/git
            target
          key: ${{ runner.os }}-cargo-${{ hashFiles('**/Cargo.lock') }}
          restore-keys: |
            ${{ runner.os }}-cargo-

      - name: Install Rust
        uses: dtolnay/rust-toolchain@stable
        with:
          targets: ${{ matrix.target }}

      - name: Install cross-compilation tools (for windows-arm64)
        if: matrix.name == 'windows-arm64'
        run: |
          sudo apt-get update
          sudo apt-get install -y gcc-aarch64-linux-gnu g++-aarch64-linux-gnu
          rustup target add aarch64-pc-windows-msvc

      - name: Run ProEngine loader tests
        if: matrix.run_tests
        run: cargo test --test pro_engine_loader_unit_tests

      - name: Run WASM runtime tests
        if: matrix.run_tests
        run: cargo test --test wasm_runtime_tests

      - name: Run Pro Engine loader tests
        if: matrix.run_tests
        run: cargo test --test pro_engine_loader_tests

      - name: Build release
        run: |
          if [ "${{ matrix.target }}" = "x86_64-unknown-linux-gnu" ] || [ "${{ matrix.target }}" = "aarch64-unknown-linux-gnu" ] || [ "${{ matrix.target }}" = "x86_64-pc-windows-msvc" ]; then
            cargo build --release
          else
            cargo build --release --target ${{ matrix.target }}
          fi

      - name: Copy binary to standard location (for cross-compiled targets)
        if: matrix.target != 'x86_64-unknown-linux-gnu' && matrix.target != 'aarch64-unknown-linux-gnu' && matrix.target != 'x86_64-pc-windows-msvc'
        run: |
          mkdir -p target/release
          cp target/${{ matrix.target }}/release/costpilot target/release/

      - name: Package
        env:
          TARGET: ${{ matrix.name }}
          COSTPILOT_VERSION: ${{ github.ref_name }}
          OUT_DIR: dist
        run: bash scripts/make_release_bundle.sh

      - name: Validate archives
        run: |
          bash scripts/verify_release_bundle.sh dist/costpilot-${{ matrix.name }}.zip
          bash scripts/verify_release_bundle.sh dist/costpilot-${{ matrix.name }}.tar.gz

      - name: Verify release policy
        if: matrix.name == 'linux-amd64'
        run: bash scripts/signing/verify_release_policy.sh

      - name: Upload ZIP
        uses: actions/upload-artifact@v4
        with:
          name: costpilot-${{ matrix.name }}.zip
          path: dist/costpilot-${{ matrix.name }}.zip

      - name: Upload TAR.GZ
        uses: actions/upload-artifact@v4
        with:
          name: costpilot-${{ matrix.name }}.tar.gz
          path: dist/costpilot-${{ matrix.name }}.tar.gz

  sign-and-release:
    runs-on: ubuntu-latest
    needs: [build]
    if: github.event_name == 'push' && startsWith(github.ref, 'refs/tags/v')
    steps:
      - uses: actions/checkout@v4

      - name: Download all artifacts
        uses: actions/download-artifact@v4
        with:
          path: dist/
          merge-multiple: true

      - name: Generate checksum file
        working-directory: dist
        run: |
          sha256sum *.zip *.tar.gz | sort > sha256sum.txt
          cat sha256sum.txt

      - name: Generate ephemeral signing key (CI-only)
        run: |
          mkdir -p build/keys
          chmod +x scripts/signing/generate_keypair.sh
          bash scripts/signing/generate_keypair.sh build/keys ci_signing

      - name: Sign checksums (Ed25519)
        run: |
          chmod +x scripts/signing/sign_checksum_ed25519.sh
          bash scripts/signing/sign_checksum_ed25519.sh dist/sha256sum.txt build/keys/ci_signing.pem dist/sha256sum.txt.sig

      - name: Verify signature (CI smoke)
        run: |
          chmod +x scripts/signing/verify_checksum_ed25519.sh
          bash scripts/signing/verify_checksum_ed25519.sh dist/sha256sum.txt dist/sha256sum.txt.sig build/keys/ci_signing.pub.pem

      - name: Generate license token (dev)
        env:
          SIGNING_SECRET: ${{ secrets.SIGNING_SECRET }}
          SOURCE_DATE_EPOCH: ${{ github.event.head_commit.timestamp }}
        run: |
          if [ -z "$SIGNING_SECRET" ]; then
            echo "SIGNING_SECRET not available, skipping license token generation"
            exit 0
          fi
          chmod +x scripts/signing/generate_license_token.sh
          bash scripts/signing/generate_license_token.sh \
            "demo-license" \
            "dev@example.com" \
            "2026-12-31T23:59:59Z" \
            "dist/license.json"

      - name: Sign checksums
        env:
          GPG_PRIVATE_KEY: ${{ secrets.GPG_PRIVATE_KEY }}
          GPG_PASSPHRASE: ${{ secrets.GPG_PASSPHRASE }}
          ED25519_PRIV: ${{ secrets.ED25519_PRIV }}
          SIGNING_SECRET: ${{ secrets.SIGNING_SECRET }}
        run: |
          chmod +x scripts/signing/sign_checksums.sh
          bash scripts/signing/sign_checksums.sh dist dist/sha256sum.txt dist/sha256sum.sig

      - name: Verify signature
        env:
          SIGNING_SECRET: ${{ secrets.SIGNING_SECRET }}
        run: |
          chmod +x scripts/signing/verify_signature.sh
          if [[ -f scripts/signing/public.key ]]; then
            bash scripts/signing/verify_signature.sh dist/sha256sum.txt dist/sha256sum.sig scripts/signing/public.key
          else
            bash scripts/signing/verify_signature.sh dist/sha256sum.txt dist/sha256sum.sig
          fi

      - name: Verify release bundles
        env:
          SIGNING_SECRET: ${{ secrets.SIGNING_SECRET }}
        run: |
          chmod +x scripts/verify_release_bundle.sh
          for artifact in dist/*.tar.gz dist/*.zip; do
            [[ -f "$artifact" ]] || continue
            bash scripts/verify_release_bundle.sh "$artifact" dist/sha256sum.txt dist/sha256sum.sig scripts/signing/public.key || true
          done

      - name: Verify publisher signature (release)
        env:
          PUBLISHER_PUBKEY: ${{ secrets.PUBLISHER_PUBKEY }}
        run: |
          if [ -z "$PUBLISHER_PUBKEY" ]; then
            echo "PUBLISHER_PUBKEY not available, skipping publisher signature verification"
            exit 0
          fi
          echo "$PUBLISHER_PUBKEY" > build/publisher.pub.pem
          chmod +x scripts/signing/verify_checksum_ed25519.sh
          bash scripts/signing/verify_checksum_ed25519.sh dist/sha256sum.txt dist/sha256sum.txt.sig build/publisher.pub.pem

      - name: Upload checksum and signature
        uses: actions/upload-artifact@v4
        with:
          name: checksums-and-signatures
          path: |
            dist/sha256sum.txt
            dist/sha256sum.sig
            dist/license.json

      - name: Create GitHub Release
        uses: softprops/action-gh-release@v1
        with:
          files: |
            dist/*.zip
            dist/*.tar.gz
            dist/sha256sum.txt
            dist/sha256sum.sig
            dist/license.json
          draft: false
          prerelease: false
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
