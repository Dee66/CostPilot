# License Webhook Implementation Guide

## Critical Issue: License Signature Validation Failure

Your endpoint is generating licenses that **fail validation** in CostPilot. This document explains why and how to fix it.

---

## Root Cause

The licenses generated by your Lemon Squeezy webhook are **signed with the wrong private key**.

CostPilot has an **embedded public key** (fingerprint: `db52fc95`) compiled into the binary at build time. This public key is stored at:
- Build script: `build.rs` (reads `LICENSE_PUBLIC_KEY` environment variable or `license_key.pub.pem`)
- Runtime constant: `crate::LICENSE_PUBLIC_KEY` in Rust code

**Your webhook MUST use the private key that corresponds to this embedded public key.**

---

## How License Validation Works

```rust
// src/pro_engine/license.rs lines 240-257
pub fn validate(&self) -> Result<(), String> {
    // 1. Check rate limiting (5 attempts/minute, 5min block)
    // 2. Check required fields exist
    // 3. Check if expired (RFC3339 date < now)
    // 4. Verify Ed25519 signature against EMBEDDED public key

    #[cfg(not(target_arch = "wasm32"))]
    {
        use crate::pro_engine::crypto;
        crypto::verify_license_signature(self)?; // ← THIS IS WHERE IT FAILS
    }

    Ok(())
}
```

The signature verification uses:
```rust
// Embedded at compile time from LICENSE_PUBLIC_KEY env var
let public_key_bytes = crate::LICENSE_PUBLIC_KEY;
let public_key = VerifyingKey::from_bytes(public_key_bytes)?;

// Data signed: email + license_key + expires
let data = format!("{}{}{}", self.email, self.license_key, self.expires);

// Verify signature
public_key.verify(data.as_bytes(), &signature).is_ok()
```

---

## Correct License Structure

Your endpoint should generate a JSON file with **exactly these fields**:

```json
{
  "email": "customer@example.com",
  "license_key": "PROD-20260110074528-12345",
  "expires": "2027-01-10T23:59:59Z",
  "signature": "<ed25519-signature-hex>",
  "issuer": "CostPilot License Authority",
  "issued_at": "2026-01-10T07:47:48Z",
  "version": "1.0"
}
```

### Field Requirements

| Field | Required | Format | Example |
|-------|----------|--------|---------|
| `email` | ✅ Yes | String | `"user@example.com"` |
| `license_key` | ✅ Yes | String (any format) | `"PROD-20260110074528-12345"` |
| `expires` | ✅ Yes | ISO 8601 / RFC3339 | `"2027-01-10T23:59:59Z"` |
| `signature` | ✅ Yes | Hex string (128 chars) | Ed25519 signature of `email+license_key+expires` |
| `issuer` | ✅ Yes | String | `"CostPilot License Authority"` |
| `issued_at` | Optional | ISO 8601 / RFC3339 | `"2026-01-10T07:47:48Z"` |
| `version` | Optional | String | `"1.0"` |

### ❌ REMOVE These Fields

These fields were mentioned in your email template but **do NOT exist in the code**:
- ❌ `product` (e.g., "CostPilot-12345")
- ❌ `variant` (e.g., "Variant-67890")

If your endpoint includes these, CostPilot will ignore them, but they're unnecessary.

---

## How to Generate Valid Licenses

### Option 1: Use the `license-issuer` Binary (Recommended)

The CostPilot repo includes a `license-issuer` binary that generates correctly signed licenses:

```bash
# Generate a license
license-issuer generate-license \
  --email "customer@example.com" \
  --license-key "PROD-20260110074528-12345" \
  --expires "2027-01-10T23:59:59Z" \
  --private-key /path/to/production/license_key.pem \
  --issuer "CostPilot License Authority" \
  --output license.json
```

**Your webhook should call this binary** via subprocess/exec and return the resulting `license.json`.

### Option 2: Implement Ed25519 Signing in Your Endpoint

If you want to generate licenses directly in your webhook code:

```python
# Python example using PyNaCl
import nacl.signing
import json
from datetime import datetime

# Load PRODUCTION private key (32 bytes)
with open('/secure/path/to/license_key.pem', 'rb') as f:
    private_key_bytes = f.read()  # Must be exactly 32 bytes

signing_key = nacl.signing.SigningKey(private_key_bytes)

# Create license data
email = "customer@example.com"
license_key = "PROD-20260110074528-12345"
expires = "2027-01-10T23:59:59Z"

# Sign the data (CRITICAL: concatenate exactly as shown)
data_to_sign = f"{email}{license_key}{expires}"
signature = signing_key.sign(data_to_sign.encode('utf-8'))

license_data = {
    "email": email,
    "license_key": license_key,
    "expires": expires,
    "signature": signature.signature.hex(),  # Convert to hex string
    "issuer": "CostPilot License Authority",
    "issued_at": datetime.utcnow().isoformat() + "Z",
    "version": "1.0"
}

return json.dumps(license_data, indent=2)
```

**JavaScript/Node.js example:**
```javascript
const sodium = require('libsodium-wrappers');
const fs = require('fs');

await sodium.ready;

// Load PRODUCTION private key (32 bytes)
const privateKey = fs.readFileSync('/secure/path/to/license_key.pem');

// License data
const email = "customer@example.com";
const licenseKey = "PROD-20260110074528-12345";
const expires = "2027-01-10T23:59:59Z";

// Sign (CRITICAL: concatenate exactly as shown)
const dataToSign = `${email}${licenseKey}${expires}`;
const signature = sodium.crypto_sign_detached(
    dataToSign,
    privateKey
);

const license = {
    email,
    license_key: licenseKey,
    expires,
    signature: Buffer.from(signature).toString('hex'),
    issuer: "CostPilot License Authority",
    issued_at: new Date().toISOString(),
    version: "1.0"
};

return JSON.stringify(license, null, 2);
```

---

## Critical Requirements

### 1. **Use the PRODUCTION Private Key**

The private key used by your webhook **MUST** correspond to the public key embedded in the released CostPilot binary.

**How to find the correct private key:**
```bash
# Check the embedded public key fingerprint in the binary
strings costpilot | grep -A 1 "License key fingerprint"
# Output: License key fingerprint: db52fc95

# Your private key file should generate this fingerprint
license-issuer generate-key  # If you need to generate a NEW keypair
```

**IMPORTANT:** If you generate a new keypair, you must:
1. Update `LICENSE_PUBLIC_KEY` environment variable during build
2. Rebuild and re-release ALL CostPilot binaries
3. Existing binaries will NOT accept licenses signed with the new key

### 2. **Signature Data Format is EXACT**

The signature MUST be computed over **exactly** this string:
```
{email}{license_key}{expires}
```

**No spaces, no separators, no JSON encoding.** Example:
```
user@example.comPROD-20260110074528-123452027-01-10T23:59:59Z
```

### 3. **Date Format Must Be RFC3339**

The `expires` field must parse as RFC3339:
```rust
// This is how CostPilot checks expiration
chrono::DateTime::parse_from_rfc3339(&self.expires)
```

Valid formats:
- ✅ `"2027-01-10T23:59:59Z"`
- ✅ `"2027-01-10T23:59:59+00:00"`
- ✅ `"2027-01-10T23:59:59.000Z"`
- ❌ `"2027-01-10"` (no time)
- ❌ `"01/10/2027"` (wrong format)

### 4. **Signature Must Be Hex String (128 characters)**

Ed25519 signatures are 64 bytes, which becomes 128 hex characters:
```
b596f2e1c804645237673954655e64a169591c295f189c4f09f450d582ccb6d27695aa83eaa40fb1db775b842ee6fdbc6a08d3ea59413e0780ec1e73f7cb7a0f
```

---

## Testing Your Webhook

### Step 1: Generate a Test License

```bash
# Use your webhook endpoint
curl -X POST https://your-endpoint.com/generate-license \
  -H "Content-Type: application/json" \
  -d '{
    "email": "test@example.com",
    "license_key": "TEST-20260110-12345",
    "expires": "2027-01-10T23:59:59Z"
  }' > test_license.json
```

### Step 2: Validate the License

```bash
# Place the license in the expected location
mkdir -p ~/.costpilot
cp test_license.json ~/.costpilot/license.json

# Try to use a premium command (diff requires Premium)
costpilot diff plan1.json plan2.json

# Expected output if license is VALID:
# Compare cost between two infrastructure plans
# (command runs normally)

# Expected output if license is INVALID:
# ⚠️  License file found but validation failed
#     Check license format or contact support
```

### Step 3: Debug Validation Failures

```bash
# Enable debug mode to see detailed errors
COSTPILOT_DEBUG=1 costpilot diff --help

# Check if rate limiting is blocking
rm ~/.costpilot/rate_limit.json
COSTPILOT_DEBUG=1 costpilot diff --help
```

Common failure reasons:
1. **Wrong private key** - Signature doesn't match embedded public key
2. **Incorrect signature data** - Signed wrong string format
3. **Expired license** - Date in past or invalid format
4. **Missing fields** - JSON missing required fields
5. **Rate limited** - Too many validation attempts (wait 5 minutes)

---

## Lemon Squeezy Webhook Integration

### Webhook Payload Structure

Lemon Squeezy sends this data on order completion:
```json
{
  "meta": {
    "event_name": "order_created"
  },
  "data": {
    "attributes": {
      "user_email": "customer@example.com",
      "order_number": 12345,
      "created_at": "2026-01-10T07:45:28.000000Z"
    }
  }
}
```

### Your Endpoint Should:

1. **Extract customer email** from webhook payload
2. **Generate license key** (e.g., `PROD-{timestamp}-{order_number}`)
3. **Set expiration date** (e.g., +1 year from now)
4. **Sign the license** using PRODUCTION private key
5. **Return license.json** to customer via email

### Example Webhook Handler (Python/Flask)

```python
from flask import Flask, request, jsonify
import subprocess
import json
from datetime import datetime, timedelta

app = Flask(__name__)

@app.route('/webhook/lemon-squeezy', methods=['POST'])
def lemon_squeezy_webhook():
    payload = request.json

    # Extract customer data
    email = payload['data']['attributes']['user_email']
    order_number = payload['data']['attributes']['order_number']

    # Generate license key
    timestamp = datetime.utcnow().strftime('%Y%m%d%H%M%S')
    license_key = f"PROD-{timestamp}-{order_number}"

    # Set expiration (1 year from now)
    expires = (datetime.utcnow() + timedelta(days=365)).strftime('%Y-%m-%dT%H:%M:%SZ')

    # Generate license using license-issuer binary
    result = subprocess.run([
        '/path/to/license-issuer',
        'generate-license',
        '--email', email,
        '--license-key', license_key,
        '--expires', expires,
        '--private-key', '/secure/path/to/production/license_key.pem',
        '--issuer', 'CostPilot License Authority',
        '--output', f'/tmp/license_{order_number}.json'
    ], capture_output=True, text=True)

    if result.returncode != 0:
        return jsonify({'error': 'License generation failed'}), 500

    # Read generated license
    with open(f'/tmp/license_{order_number}.json', 'r') as f:
        license_data = json.load(f)

    # TODO: Email license.json to customer
    # send_email_with_attachment(email, f'/tmp/license_{order_number}.json')

    return jsonify({
        'success': True,
        'license_key': license_key,
        'email': email
    })
```

---

## Security Checklist

- [ ] **Private key is stored securely** (not in version control)
- [ ] **Private key has restricted file permissions** (chmod 600)
- [ ] **Webhook endpoint validates Lemon Squeezy signature** (prevents spoofing)
- [ ] **License expiration is set appropriately** (e.g., 1 year)
- [ ] **Generated licenses are logged** (for customer support)
- [ ] **Rate limiting is implemented** (prevent abuse)
- [ ] **Webhook is HTTPS only** (no HTTP)

---

## File Locations Reference

### In CostPilot Repository:
- License validation logic: `src/pro_engine/license.rs` (lines 165-257)
- Edition detection: `src/edition/mod.rs` (lines 1-70)
- Public key embedding: `build.rs` (reads LICENSE_PUBLIC_KEY)
- License issuer binary: `src/bin/license_issuer.rs`
- License issuer library: `costpilot-license-issuer/src/lib.rs`

### Customer Installation Paths:
- Linux/Mac: `~/.costpilot/license.json`
- Windows: `C:\Users\<username>\.costpilot\license.json`
- Rate limit file: `~/.costpilot/rate_limit.json`

### Webhook Server Paths (you must configure):
- Production private key: `/secure/path/to/license_key.pem` (32 bytes, Ed25519)
- License issuer binary: `/path/to/license-issuer` (from CostPilot releases)

---

## Quick Verification

After implementing the fix:

```bash
# 1. Generate test license via webhook
curl -X POST https://your-endpoint.com/webhook/lemon-squeezy \
  -H "Content-Type: application/json" \
  -d '{"data": {"attributes": {"user_email": "test@example.com", "order_number": 12345}}}' \
  > test_webhook_license.json

# 2. Install it
mkdir -p ~/.costpilot
cp test_webhook_license.json ~/.costpilot/license.json

# 3. Test premium command
costpilot diff plan1.json plan2.json

# 4. Verify edition
costpilot --version
# Should show: CostPilot 1.0.0 (Premium)
```

If the above works, your webhook is **correctly configured**.

---

## Support

If licenses still fail validation after following these steps:

1. Check the embedded public key fingerprint in your released binary
2. Verify your private key generates the same public key fingerprint
3. Compare generated license.json structure to examples in this document
4. Test signature generation with the `license-issuer` binary directly
5. Check build.rs for how LICENSE_PUBLIC_KEY is embedded

**The most common issue is using a test keypair instead of the production keypair.**
